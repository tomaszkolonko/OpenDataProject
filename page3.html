<!DOCTYPE html>
<meta charset="utf-8">

<body>
    <p class="line">Test</p>
    <a id="ind0" class="myButton">ind0</a>
    <a id="ind1" class="myButton">ind1</a>
    <a id="ind2" class="myButton">ind2</a>
    <a id="ind3" class="myButton">ind3</a>
    <a id="ind4" class="myButton">ind4</a>
    <a id="ind5" class="myButton">ind5</a>
    <a id="ind6" class="myButton">ind6</a>
    <a id="ind7" class="myButton">ind7</a>
    <script src="./js/d3.js"></script>
    <script src="./js/topojson.js"></script>
    <link rel="stylesheet" type="text/css" href="css/style.css">
<script>

/* ********* PreWork ************* */

    // use global variables for checking
    // TODO delete afterwards
    var global_data, cities_display;
    
    // Default Value
    // TODO should be an empty at beginning
    var indikator = "ind2";

    var margin = {top: 20, right: 80, bottom: 30, left: 80};

    var width_graph = 960 - margin.left - margin.right;
    var height_graph = 500 - margin.top - margin.bottom;

    var witdth_map = 572;
    var height_map = 780;
    var scale_map = 0.85;


    var x = d3.scale.linear()
        .range([0, width_graph]);

    var y = d3.scale.linear()
        .range([height_graph, 0]);

    var color = d3.scale.category10();

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .tickFormat(d3.format("d"));

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");
    
    var buttons = d3.select("body").append("div")
    .attr("class", "buttons");
    
    /* ************ map *************** */

    var svg_map = d3.select("body").append("svg")
        .attr("width", witdth_map)
        .attr("height", height_map)

    var map =  svg_map.append("g")
        .attr('id', 'map')
        //.attr('transform','translate('+((1 - scale) * width/2)+','+((1 - scale) * mapH/2)+')scale('+scale+')');
        .attr('transform','translate('+0+','+0+')scale('+scale_map+')');

    var mapPfade =  map.append("g")
        .attr('id', 'mapPfade')
        .attr('transform', 'translate(30,0)');

    // TODO: wont work out of the box anymore
    var line = d3.svg.line()
        .interpolate("basis")
        .x(function(d) { return x(d.date); })
        .y(function(d) { return y(d.spending); });

    var svg_graph = d3.select("body").append("svg")
        .attr("width", width_graph + margin.left + margin.right)
        .attr("height", height_graph + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var labels = d3.select("body").append("div")
        .attr("class", "labels");

/* ********* Work with DATA ************* */


d3.json("map/gemeinden2015_gefis.json", function(error, topoJson) {
    
    
    // Alle darzustellenden Gemeinden kommen hier rein
    var aktive_Gemeinden = [];
    
    //// Projektion ////
    var path= d3.geo.path()
            .projection(null)
    
    var gemeindeDaten = topoJson.objects.gemeinden2015.geometries;
    var ArrayofYears = d3.keys(gemeindeDaten[0].properties.ind0);
    
    console.log(gemeindeDaten);
    
    // TODO nur als Beispiel das erste Element genommen
    aktive_Gemeinden.push(gemeindeDaten[0]);
    aktive_Gemeinden.push(gemeindeDaten[1]);

    // adapt domains of x and y
    x.domain([
        d3.min(ArrayofYears, function(d) { return +d; }),
        d3.max(ArrayofYears, function(d) { return +d; })
    ]);
    xAxis.tickValues(ArrayofYears);

    y.domain([
        d3.min(aktive_Gemeinden, function(c) { return d3.min(d3.values(c.properties.ind2))}),
        d3.max(aktive_Gemeinden, function(c) { return d3.max(d3.values(c.properties.ind2))})
    ]);    

    //// Generate Map ////
    var gemeinden = mapPfade.selectAll('.gemeinden')
            .data(topojson.feature(topoJson, topoJson.objects.gemeinden2015).features)
            .enter()
            .append('path')
            .attr("d", path)
    //.attr('id', 'bfs'+d.bfs)
            .attr("class", function(d) {
                    if (d.properties.ART_TEXT == 'See' ){
                            return 'see';
                    }  else {
                            return 'gemeinden';
                    }
            });

// First line
// d3.select('bfs'+261).attr('class'. 'selected');
// drawLine('bfs261');
    
    function checkIfActiveAndRemove(tmpGemeinde) {
        for(var i = 0; i < aktive_Gemeinden.length; i++) {
            if(aktive_Gemeinden[i].properties.BFS === tmpGemeinde.properties.BFS) {
                aktive_Gemeinden.splice(i,1);
                return true;
            }
        }
        return false;
    }
    
    svg_graph.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height_graph + ")")
          .call(xAxis);

    svg_graph.append("g")
          .attr("class", "y axis")
          .call(yAxis)
          .append("text")
          .attr("x", 30)
          .attr("y", 0)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .text("CHF/Einwohner")
          .attr("x", 80);
    
    var gemeinden_graph = svg_graph.selectAll(".city")
        .data(aktive_Gemeinden)
        .enter()
        .append("g")
        .attr("class", "city");
    
    // casts an object into an array for easier element/element
    // processing line method.
    // TODO: check if refactoring ommits it
    function cast(o) {
        var castArray = [];
        for(var key in o) {
            var val = o[key];
            castArray.push({date: +key, spending: +val});
        }
        return castArray;
    }

    gemeinden_graph.append("path")
        .attr("class", function(d) { return "line " + d.properties.NAME; })
        .attr("d", function(d) { return (line(cast(d.properties.ind2))); })
        .style("stroke", function(d) { return color(d.properties.NAME); })
	    .style("opacity", function(d) { return 1; });
    
    gemeinden_graph.append("text")
        .attr("transform", function(d) { return "translate(" + x(2014) + "," + y(d.properties.ind2["2014"]) + ")"; })
        .attr("x", 3)
        .attr("dy", ".35em")
        .attr("class", function(d) { return d.properties.NAME.split(" ")[0]; })
        .text(function(d) { return d.properties.NAME.split(" ")[0]; });
    
    
    ////////////////////////////////
    //// UPDATE THE WHOLE GRAPH ////
    ////////////////////////////////
    
    function updateGraph(indi) {
            console.log("indi"); console.log(indi);
            if(indi !== "none") {
                indikator = indi;
            }
        
        //// TODO //// MAKE THE CALCULATION YOURSELF
        
        y.domain([
                d3.min(aktive_Gemeinden, function(c) { console.log(d3.min(d3.values(eval("c.properties." + indikator)))); return d3.min(d3.values(eval("c.properties." + indikator)))}),
                d3.max(aktive_Gemeinden, function(c) { console.log(d3.max(d3.values(eval("c.properties." + indikator)))); return d3.max(d3.values(eval("c.properties." + indikator)))})
            ]);
        
        console.log("min"); console.log(d3.min(aktive_Gemeinden, function(c) { return d3.min(d3.values(eval("c.properties." + indikator)))}));
        console.log("max"); console.log(d3.max(aktive_Gemeinden, function(c) { return d3.max(d3.values(eval("c.properties." + indikator)))}));
        
            var chooseCorrectIndikator = "d.properties." + indikator;
            var chooseCorrectSpendingForText = "d.properties." + indikator + "['2014']";
        
            console.log("chooseCorrectIndikator"); console.log(chooseCorrectIndikator);
            console.log("chooseCorrectSpendingForText"); console.log(chooseCorrectSpendingForText);
        
            //// UPDATE Y AXIS ////
            svg_graph.select(".y.axis").transition().duration(800).call(yAxis);
            
            //// UPDATE SELECTION ////
            gemeinden_graph = svg_graph.selectAll(".city").data(aktive_Gemeinden);
        
            //// UPDATE EXISTING PATHS ////
            gemeinden_graph.selectAll("path")
                .transition()
                .duration(800)
                .attr("d", function(d) { console.log("->"); console.log(eval(chooseCorrectIndikator)); return (line(cast(eval(chooseCorrectIndikator)))); });
        
            //// UPDATE EXISTING LABELS ////
            gemeinden_graph.selectAll("text")
                .transition()
                .duration(800)
                .attr("transform", function(d) { return "translate(" + x(2014) + "," + y(eval(chooseCorrectSpendingForText)) + ")"; });
        
            //// ENTER NEW PATHS ////
            var newEntry = gemeinden_graph
                .enter()
                .append("g")
                .attr("class", "city");
            newEntry.append("path").attr("class", function(d) { return "line " + d.properties.NAME; })
                .attr("d", function(d) { return (line(cast(eval(chooseCorrectIndikator)))); })
                .style("stroke", function(d) { return color(d.properties.NAME); })
                .style("opacity", 0)
                .transition().delay(300).duration(800)
                .style("opacity", 1);
            newEntry.append("text")
                .style("opacity", 0)
                .attr("transform", function(d) { return "translate(" + x(2014) + "," + y(eval(chooseCorrectSpendingForText)) + ")"; })
                .attr("class", function(d) { return d.properties.NAME; })
                .text(function(d) { return d.properties.NAME; })
                .attr("x", 3)
                .attr("dy", ".35em")
                //.style("opacity", 0)
                //.transition().duration(800) // CONFLICTS WITH UPPER TRANSITION
                // second style attribute never run since transition stopped
                .style("opacity", 1);
                
            //// EXIT NOT USED CITIES ////
            gemeinden_graph
                .exit()
                .transition()
                .duration(500)
                .style("opacity", 0)
                .remove();
    
    }
    
    d3.select("body").selectAll(".myButton").on("click", function(d) {
        updateGraph(d3.select(this)[0][0].id);
    });
    
    // AT THE MOMENT NOT USED: maybe to solve the transition problem....
    function updateTextLabels() {
            //// UPDATE SELECTION ////
        
        // AT THE MOMENT NOT USED: maybe to solve the transition problem....
        gemeinden_graph = svg_graph.selectAll(".city").data(aktive_Gemeinden);
        
        console.log(aktive_Gemeinden);
        gemeinden_graph.selectAll("text")
                //.datum(function(d) { return {name: d.properties.NAME.split(' ')[0], date: 2014, spending: d.properties.ind2["2014"] }; })
                .transition()
                .duration(800)
                .attr("transform", function(d) { return "translate(" + x(2014) + "," + y(d.properties.ind2["2014"]) + ")"; });
        
        //gemeinden_graph.selectAll("text").enter().append("g")
            
    }
             
    //// UPDATE ////
    d3.selectAll('.gemeinden')
        .attr('cursor', 'pointer')
        .on('click', function(d) {
            var mouseGem = d3.select(this);
            var tmpGemeinde = mouseGem[0][0].__data__;
            if(!checkIfActiveAndRemove(tmpGemeinde)) {
                aktive_Gemeinden.push(tmpGemeinde);
            }
            
            updateGraph("none");
            //updateTextLabels();

                    
                    // wichtig: nicht nur mit this arbeiten, sondern mit d3.select(this)
                    // d3 selection liefert anderes Objekt zurück als reines javascript this
                    // d3.selection beinhaltet databindings!
                    // vergleiche mal console.log(d3.select(this)) mit console.log(this);
            })

});



</script>
</body>